{"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/testdrs\/testingasynchronouscode"]}],"metadata":{"title":"Testing asynchronous code","modules":[{"name":"TestDRS"}],"roleHeading":"Article","role":"article"},"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Modern Swift applications commonly use asynchronous programming with ","type":"text"},{"code":"async\/await","type":"codeVoice"},{"type":"text","text":" for operations like network requests, database access, and other potentially long-running tasks. Testing asynchronous code presents unique challenges, but TestDRS provides solutions to make it straightforward. This article will guide you through testing asynchronous code and verifying expectations using TestDRS."}]},{"level":2,"anchor":"Prefer-direct-awaiting-when-possible","type":"heading","text":"Prefer direct awaiting when possible"},{"inlineContent":[{"type":"text","text":"The most straightforward way to test asynchronous code is to make your test functions async and directly await the operations:"}],"type":"paragraph"},{"code":["func testFetchWeather() async throws {","    \/\/ Arrange","    let mockWeatherService = MockWeatherService()","    let expectedWeather = Weather(temperature: 72, condition: .sunny)","    #stub(mockWeatherService.fetchWeather, with: \"San Francisco\", returning: expectedWeather)","    ","    let viewModel = WeatherViewModel(weatherService: mockWeatherService)","    ","    \/\/ Act - directly await the async operation","    try await viewModel.loadWeather(for: \"San Francisco\")","    ","    \/\/ Assert","    XCTAssertEqual(viewModel.currentWeather, expectedWeather)","    #expectWasCalled(mockWeatherService.fetchWeather, with: \"San Francisco\")","}"],"type":"codeListing","syntax":"swift"},{"type":"heading","anchor":"Common-mistake-Unnecessary-use-of-Task","text":"Common mistake: Unnecessary use of Task","level":3},{"inlineContent":[{"text":"A common mistake is wrapping async calls in a ","type":"text"},{"code":"Task","type":"codeVoice"},{"text":" when it’s not necessary:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/ ❌ INCORRECT: Unnecessarily using Task","func testFetchWeather() throws {","    let mockWeatherService = MockWeatherService()","    let viewModel = WeatherViewModel(weatherService: mockWeatherService)","    ","    \/\/ This creates a Task but doesn't wait for it to complete","    Task {","        try await viewModel.loadWeather(for: \"San Francisco\")","    }","    ","    \/\/ ⚠️ This assertion might run before the Task completes","    #expectWasCalled(mockWeatherService.fetchWeather, with: \"San Francisco\")","}","","\/\/ ✅ CORRECT: Simply make the test async","func testFetchWeather() async throws {","    let mockWeatherService = MockWeatherService()","    let viewModel = WeatherViewModel(weatherService: mockWeatherService)","    ","    \/\/ Directly await the async operation","    try await viewModel.loadWeather(for: \"San Francisco\")","    ","    \/\/ This assertion runs after the async operation completes","    #expectWasCalled(mockWeatherService.fetchWeather, with: \"San Francisco\")","}"],"syntax":"swift"},{"type":"heading","anchor":"Refactoring-production-code-for-testability","text":"Refactoring production code for testability","level":3},{"inlineContent":[{"type":"text","text":"Sometimes, you might need to refactor your production code to make it more testable. For example, if your code dispatches work to background tasks, consider exposing an async function that can be directly awaited:"}],"type":"paragraph"},{"type":"codeListing","code":["\/\/ ❌ HARD TO TEST: Fire-and-forget Task creation","class WeatherViewModel {","    func loadWeatherInBackground(for city: String) {","        Task {","            do {","                let weather = try await weatherService.fetchWeather(for: city)","                self.currentWeather = weather","            } catch {","                self.error = error","            }","        }","    }","}","","\/\/ ✅ EASIER TO TEST: Expose an async function","class WeatherViewModel {","    func loadWeather(for city: String) async {","        do {","            let weather = try await weatherService.fetchWeather(for: city)","            self.currentWeather = weather","        } catch {","            self.error = error","        }","    }","    ","    \/\/ Keep the fire-and-forget method, but have it call the async method","    func loadWeatherInBackground(for city: String) {","        Task {","            await loadWeather(for: city)","        }","    }","}"],"syntax":"swift"},{"anchor":"When-to-use-confirmationOfCall","type":"heading","level":2,"text":"When to use `#confirmationOfCall`"},{"type":"paragraph","inlineContent":[{"type":"text","text":"While direct awaiting is preferable, there are scenarios where you can’t directly await an operation:"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"Testing code that uses timers or debouncing","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Testing event-driven systems (like Combine publishers)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Testing callbacks from notification systems"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Testing code that creates detached tasks you can’t await"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Testing asynchronous UI interactions","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"In these cases, ","type":"text"},{"type":"codeVoice","code":"#confirmationOfCall"},{"type":"text","text":" provides a way to asynchronously wait for and verify function calls."}]},{"level":3,"text":"Example: Testing notification observers","type":"heading","anchor":"Example-Testing-notification-observers"},{"code":["class NetworkMonitor {","    private let networkClient: NetworkClientProtocol","    ","    init(networkClient: NetworkClientProtocol) {","        self.networkClient = networkClient","        setupNotifications()","    }","    ","    private func setupNotifications() {","        NotificationCenter.default.addObserver(","            self,","            selector: #selector(appDidBecomeActive),","            name: UIApplication.didBecomeActiveNotification,","            object: nil","        )","    }","    ","    @objc private func appDidBecomeActive() {","        Task {","            try? await networkClient.checkConnectivity()","        }","    }","}","","\/\/ Testing with confirmationOfCall","func testNetworkMonitorChecksConnectivityWhenAppBecomesActive() async {","    \/\/ Arrange","    let mockNetworkClient = MockNetworkClient()","    let monitor = NetworkMonitor(networkClient: mockNetworkClient)","    ","    \/\/ Act - post the notification","    NotificationCenter.default.post(","        name: UIApplication.didBecomeActiveNotification,","        object: nil","    )","    ","    \/\/ Assert - wait for the async call triggered by the notification","    await #confirmationOfCall(to: mockNetworkClient.checkConnectivity)","}"],"syntax":"swift","type":"codeListing"},{"level":2,"text":"Controlling time limits","anchor":"Controlling-time-limits","type":"heading"},{"inlineContent":[{"text":"By default, ","type":"text"},{"type":"codeVoice","code":"#confirmationOfCall"},{"text":" will wait an infinite time, but you can specify a custom time limit:","type":"text"}],"type":"paragraph"},{"code":["\/\/ Wait up to 5 seconds for a long-running operation","await #confirmationOfCall(to: mockLongRunningService.process, timeLimit: .seconds(5))"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","anchor":"Verifying-the-number-of-calls","text":"Verifying the number of calls"},{"type":"paragraph","inlineContent":[{"text":"On its own, ","type":"text"},{"code":"#confirmationOfCall","type":"codeVoice"},{"type":"text","text":" waits for a single call. Just as with "},{"code":"expectWasCalled","type":"codeVoice"},{"type":"text","text":" though, you can verify multiple calls using "},{"code":"occurring","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"occurringWithin"},{"text":":","type":"text"}]},{"code":["\/\/ Confirm the function was called exactly 3 times","await #confirmationOfCall(to: mockClient.fetchData)","    .occurring(times: 3)","    ","\/\/ Confirm the function was called between 2 and 5 times","await #confirmationOfCall(to: mockClient.fetchData)","    .occurringWithin(times: 2...5)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use "},{"type":"codeVoice","code":"exactlyOnce"},{"type":"text","text":" to verify that additional calls were not made:"}]},{"code":["\/\/ Confirm the function was called exactly once","await #confirmationOfCall(to: mockClient.fetchData)","    .exactlyOnce()"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Note that for any of these methods, additional calls may be made after the test is finished without causing a failure.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is because these methods do not introduce any sort of artificial delay in order to wait for a failure to occur."}]},{"text":"Summary","anchor":"Summary","type":"heading","level":2},{"inlineContent":[{"text":"Testing asynchronous code using TestDRS is straightforward when following these principles:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Directly await async operations whenever possible"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Refactor production code to make it more testable when needed"}]}]},{"content":[{"inlineContent":[{"text":"Use ","type":"text"},{"type":"codeVoice","code":"confirmationOfCall"},{"text":" only when you can’t directly await the operation","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"By following these guidelines, you can write reliable tests for even complex asynchronous behavior in your Swift applications."}],"type":"paragraph"}]}],"kind":"article","hierarchy":{"paths":[["doc:\/\/TestDRS\/documentation\/TestDRS"]]},"abstract":[{"type":"text","text":"Learn best practices for testing asynchronous Swift code with TestDRS."}],"seeAlsoSections":[{"generated":true,"anchor":"Asynchronous-testing","title":"Asynchronous testing","identifiers":["doc:\/\/TestDRS\/documentation\/TestDRS\/confirmationOfCall(to:taking:returning:timeLimit:isolation:)","doc:\/\/TestDRS\/documentation\/TestDRS\/confirmationOfCall(to:with:returning:timeLimit:isolation:)","doc:\/\/TestDRS\/documentation\/TestDRS\/FunctionCallConfirmation"]}],"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/TestDRS\/documentation\/TestDRS\/TestingAsynchronousCode"},"references":{"doc://TestDRS/documentation/TestDRS/confirmationOfCall(to:with:returning:timeLimit:isolation:)":{"title":"confirmationOfCall(to:with:returning:timeLimit:isolation:)","type":"topic","kind":"symbol","url":"\/documentation\/testdrs\/confirmationofcall(to:with:returning:timelimit:isolation:)","fragments":[{"text":"macro","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"confirmationOfCall"},{"kind":"text","text":"<each "},{"kind":"genericParameter","text":"Input"},{"text":", ","kind":"text"},{"kind":"genericParameter","text":"Output"},{"text":">(","kind":"text"},{"kind":"externalParam","text":"to"},{"kind":"text","text":": (repeat each "},{"text":"Input","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"with","kind":"externalParam"},{"kind":"text","text":": repeat each "},{"text":"Input","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"returning","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Output","kind":"typeIdentifier"},{"text":".Type?, ","kind":"text"},{"text":"timeLimit","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:s8DurationV","kind":"typeIdentifier","text":"Duration"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"isolation"},{"kind":"text","text":": "},{"text":"isolated","kind":"keyword"},{"text":" (any ","kind":"text"},{"preciseIdentifier":"s:ScA","kind":"typeIdentifier","text":"Actor"},{"text":")?) -> ","kind":"text"},{"text":"FunctionCallConfirmation","kind":"typeIdentifier","preciseIdentifier":"s:7TestDRS24FunctionCallConfirmationV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","preciseIdentifier":"s:7TestDRS13MatchingFirstO","text":"MatchingFirst"},{"text":", (repeat each ","kind":"text"},{"kind":"typeIdentifier","text":"Input"},{"kind":"text","text":"), "},{"text":"Output","kind":"typeIdentifier"},{"kind":"text","text":">"}],"abstract":[{"text":"Awaits confirmation of a function call with an expected input.","type":"text"}],"identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/confirmationOfCall(to:with:returning:timeLimit:isolation:)","role":"symbol"},"doc://TestDRS/documentation/TestDRS/confirmationOfCall(to:taking:returning:timeLimit:isolation:)":{"url":"\/documentation\/testdrs\/confirmationofcall(to:taking:returning:timelimit:isolation:)","role":"symbol","type":"topic","abstract":[{"type":"text","text":"Awaits confirmation of a function call."}],"title":"confirmationOfCall(to:taking:returning:timeLimit:isolation:)","fragments":[{"kind":"keyword","text":"macro"},{"text":" ","kind":"text"},{"kind":"identifier","text":"confirmationOfCall"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"Input"},{"kind":"text","text":", "},{"text":"Output","kind":"genericParameter"},{"kind":"text","text":">("},{"text":"to","kind":"externalParam"},{"text":": (","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"async","kind":"keyword"},{"text":" ","kind":"text"},{"text":"throws","kind":"keyword"},{"kind":"text","text":" -> "},{"text":"Output","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"taking","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Input","kind":"typeIdentifier"},{"text":".Type?, ","kind":"text"},{"text":"returning","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Output"},{"text":".Type?, ","kind":"text"},{"kind":"externalParam","text":"timeLimit"},{"kind":"text","text":": "},{"text":"Duration","kind":"typeIdentifier","preciseIdentifier":"s:s8DurationV"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"isolation"},{"text":": ","kind":"text"},{"text":"isolated","kind":"keyword"},{"kind":"text","text":" (any "},{"kind":"typeIdentifier","preciseIdentifier":"s:ScA","text":"Actor"},{"text":")?) -> ","kind":"text"},{"preciseIdentifier":"s:7TestDRS24FunctionCallConfirmationV","kind":"typeIdentifier","text":"FunctionCallConfirmation"},{"kind":"text","text":"<"},{"preciseIdentifier":"s:7TestDRS13MatchingFirstO","text":"MatchingFirst","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"Input","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"Output","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/confirmationOfCall(to:taking:returning:timeLimit:isolation:)","kind":"symbol"},"doc://TestDRS/documentation/TestDRS":{"title":"TestDRS","type":"topic","url":"\/documentation\/testdrs","abstract":[{"type":"text","text":"A modern Swift testing library that provides powerful mocking, stubbing, and verification capabilities through Swift macros."}],"kind":"symbol","identifier":"doc:\/\/TestDRS\/documentation\/TestDRS","role":"collection"},"doc://TestDRS/documentation/TestDRS/FunctionCallConfirmation":{"navigatorTitle":[{"text":"FunctionCallConfirmation","kind":"identifier"}],"identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/FunctionCallConfirmation","url":"\/documentation\/testdrs\/functioncallconfirmation","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"FunctionCallConfirmation","kind":"identifier"}],"role":"symbol","type":"topic","abstract":[{"type":"text","text":"Encapsulates the result of a "},{"code":"#confirmationOfCall","type":"codeVoice"},{"text":".","type":"text"}],"title":"FunctionCallConfirmation"}}}