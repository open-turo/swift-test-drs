{"metadata":{"modules":[{"name":"TestDRS"}],"role":"article","title":"Getting started with TestDRS","roleHeading":"Article"},"variants":[{"paths":["\/documentation\/testdrs\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"Learn how to use TestDRS to create and use mocks in your Swift unit tests."}],"kind":"article","sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/TestDRS\/documentation\/TestDRS\/GettingStarted"},"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/TestDRS\/documentation\/TestDRS"]]},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"inlineContent":[{"type":"text","text":"TestDRS is a powerful Swift testing library that makes it easy to create mock implementations of your protocols, classes, and structs. With TestDRS, you can write tests that isolate the code being tested from its dependencies, making your tests more reliable and focused."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This article will walk you through the basic steps of:"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Installing TestDRS"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Creating your first mock"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Using mocks in your tests"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Stubbing methods"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Verifying function calls","type":"text"}],"type":"paragraph"}]}]},{"anchor":"Installation","level":2,"type":"heading","text":"Installation"},{"type":"heading","level":3,"anchor":"Swift-Package-Manager","text":"Swift Package Manager"},{"inlineContent":[{"type":"text","text":"Add TestDRS to your project by adding it as a dependency in your "},{"type":"codeVoice","code":"Package.swift"},{"text":" file:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/turo\/swift-test-drs.git\", from: \"1.0.0\")","]"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Then add TestDRS to your test target:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":[".testTarget(","    name: \"YourTests\",","    dependencies: [\"TestDRS\"]",")"]},{"type":"heading","anchor":"Creating-your-first-mock","text":"Creating your first mock","level":2},{"type":"paragraph","inlineContent":[{"text":"There are two primary ways to create mocks with TestDRS: using ","type":"text"},{"code":"@AddMock","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"@Mock","type":"codeVoice"},{"text":". Let’s look at both approaches.","type":"text"}]},{"text":"Using @AddMock","level":3,"type":"heading","anchor":"Using-AddMock"},{"inlineContent":[{"type":"text","text":"The "},{"code":"@AddMock","type":"codeVoice"},{"text":" macro is applied to a production type and generates a mock type alongside it. This is the recommended approach for most cases, as it keeps your mock in sync with your production code.","type":"text"}],"type":"paragraph"},{"code":["import TestDRS","","@AddMock","protocol WeatherService {","    func fetchWeather(for city: String) throws -> Weather","    var defaultCity: String { get set }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This generates a "},{"type":"codeVoice","code":"MockWeatherService"},{"text":" class wrapped in an ","type":"text"},{"code":"#if DEBUG","type":"codeVoice"},{"text":" directive, making it available in test and debug builds but not in release builds.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Using-Mock","level":3,"text":"Using @Mock"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Mock"},{"type":"text","text":" macro is applied directly to a mock type that you create. This approach allows you to declare a mock in a test target, but requires you to keep the mock in sync with the production code manually. Luckily Xcode will provide a fixit to quickly fill in any missing members required for protocol conformance, so the boilerplate required is still minimal. Of note, you don’t write any method bodies or property accessors when using "},{"code":"@Mock","type":"codeVoice"},{"type":"text","text":", as the macro generates them for you."}]},{"syntax":"swift","type":"codeListing","code":["import TestDRS","","@Mock","class MockWeatherService: WeatherService {","    var defaultCity: String","    func fetchWeather(for city: String) throws -> Weather","}"]},{"type":"heading","level":3,"text":"Choosing between @AddMock and @Mock","anchor":"Choosing-between-AddMock-and-Mock"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Use "},{"code":"@AddMock","type":"codeVoice"},{"type":"text","text":" when:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"You want to keep your mock automatically in sync with your production code"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You want to use your mocks with SwiftUI previews"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"@Mock"},{"text":" when:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You don’t want your mock accessible in your production target, even in debug"}]}]}],"type":"unorderedList"}]}]},{"type":"heading","level":2,"text":"Using mocks in tests","anchor":"Using-mocks-in-tests"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that you have a mock, you can use it in your tests. The example below introduces stubbing and verification, which we’ll explain in more detail in the following sections:"}]},{"code":["import XCTest","import TestDRS","@testable import YourApp","","final class WeatherViewModelTests: XCTestCase {","    func testFetchWeather() throws {","        \/\/ Create a mock","        let mockWeatherService = MockWeatherService()","        ","        \/\/ Create the system under test with the mock","        let viewModel = WeatherViewModel(weatherService: mockWeatherService)","        ","        \/\/ Stub the mock","        let expectedWeather = Weather(temperature: 72, condition: .sunny)","        #stub(mockWeatherService.fetchWeather, returning: expectedWeather)","        ","        \/\/ Act","        viewModel.loadWeather(for: \"San Francisco\")","        ","        \/\/ Assert","        #expectWasCalled(mockWeatherService.fetchWeather, with: \"San Francisco\")","        XCTAssertEqual(viewModel.currentWeather, expectedWeather)","    }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Stubbing-methods","type":"heading","level":2,"text":"Stubbing methods"},{"type":"paragraph","inlineContent":[{"type":"text","text":"TestDRS provides macros to stub method calls on your mock objects:"}]},{"level":3,"text":"Returning a value","type":"heading","anchor":"Returning-a-value"},{"syntax":"swift","type":"codeListing","code":["#stub(mockWeatherService.fetchWeather, taking: String.self, returning: Weather(temperature: 72, condition: .sunny))"]},{"level":3,"type":"heading","text":"Throwing an error","anchor":"Throwing-an-error"},{"code":["#stub(mockWeatherService.fetchWeather, taking: String.self, throwing: NetworkError.serverError)"],"syntax":"swift","type":"codeListing"},{"type":"heading","level":3,"text":"Using a closure","anchor":"Using-a-closure"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more complex behavior, you can provide a closure:"}]},{"syntax":"swift","code":["#stub(mockWeatherService.fetchWeather, using: { city in","    if city == \"San Francisco\" {","        return Weather(temperature: 72, condition: .sunny)","    } else {","        throw NetworkError.notFound","    }","})"],"type":"codeListing"},{"anchor":"Verifying-function-calls","level":2,"type":"heading","text":"Verifying function calls"},{"inlineContent":[{"type":"text","text":"After running your code under test, you’ll often want to verify that certain methods were called with specific parameters:"}],"type":"paragraph"},{"anchor":"Verify-a-call-was-made","level":3,"text":"Verify a call was made","type":"heading"},{"syntax":"swift","code":["#expectWasCalled(mockWeatherService.fetchWeather)"],"type":"codeListing"},{"anchor":"Verify-a-call-was-not-made","text":"Verify a call was not made","type":"heading","level":3},{"type":"codeListing","code":["#expectWasNotCalled(mockWeatherService.fetchWeather)"],"syntax":"swift"},{"level":3,"text":"Checking call counts","anchor":"Checking-call-counts","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can also verify the number of times a method was called:","type":"text"}]},{"syntax":"swift","code":["#expectWasCalled(mockWeatherService.fetchWeather)","    .exactlyOnce()"],"type":"codeListing"},{"type":"codeListing","syntax":"swift","code":["#expectWasCalled(mockWeatherService.fetchWeather)","    .occurring(times: 3)"]},{"syntax":"swift","code":["#expectWasCalled(mockWeatherService.fetchWeather)","    .occurringWithin(times: 2...5)"],"type":"codeListing"},{"level":3,"anchor":"Verify-a-call-was-made-with-specific-arguments","text":"Verify a call was made with specific arguments","type":"heading"},{"inlineContent":[{"text":"If the input to the method you are testing is Equatable, you can pass those arguments into ","type":"text"},{"code":"#expectWasCalled","type":"codeVoice"},{"type":"text","text":" in order to verify that the method was called with the expected arguments:"}],"type":"paragraph"},{"code":["#expectWasCalled(mockWeatherService.fetchWeather, with: \"San Francisco\")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"For methods with multiple arguments, you can pass them as variadic parameters:","type":"text"}],"type":"paragraph"},{"code":["\/\/ For a method like: func logEvent(name: String, parameters: [String: Any], count: Int)","#expectWasCalled(mockAnalytics.logEvent, with: \"button_click\", [\"id\": \"login_button\"], 1)"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"If the arguments aren’t Equatable, you can instead get the input of the function and then verify the arguments individually:","type":"text"}]},{"code":["\/\/ For a method like: func processData(data: CustomData, options: ProcessingOptions)","let result = #expectWasCalled(mockProcessor.processData)","    .exactlyOnce()","let call = try result.getMatchingCall()","let (data, options) = call.input","","\/\/ Now you can verify the arguments","XCTAssertEqual(data.id, \"12345\")","XCTAssertTrue(options.preserveMetadata)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"getMatchingCall()"},{"text":" method returns the recorded function call, allowing you to access its ","type":"text"},{"type":"codeVoice","code":"input"},{"text":" property. For methods with multiple parameters, the input is represented as a tuple, which you can destructure to access individual parameters.","type":"text"}]},{"type":"heading","level":2,"text":"Next steps","anchor":"Next-steps"},{"type":"paragraph","inlineContent":[{"text":"Now that you’ve learned the basics of TestDRS, check out these additional articles:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"isActive":true,"type":"reference","identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/TestingAsynchronousCode"},{"type":"text","text":" - Learn how to test async functions"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"reference","identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/TestingStaticMembers","isActive":true},{"type":"text","text":" - Discover how to test static properties and methods"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"references":{"doc://TestDRS/documentation/TestDRS":{"title":"TestDRS","type":"topic","url":"\/documentation\/testdrs","abstract":[{"type":"text","text":"A modern Swift testing library that provides powerful mocking, stubbing, and verification capabilities through Swift macros."}],"kind":"symbol","identifier":"doc:\/\/TestDRS\/documentation\/TestDRS","role":"collection"},"doc://TestDRS/documentation/TestDRS/TestingAsynchronousCode":{"kind":"article","url":"\/documentation\/testdrs\/testingasynchronouscode","role":"article","identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/TestingAsynchronousCode","abstract":[{"type":"text","text":"Learn best practices for testing asynchronous Swift code with TestDRS."}],"title":"Testing asynchronous code","type":"topic"},"doc://TestDRS/documentation/TestDRS/TestingStaticMembers":{"url":"\/documentation\/testdrs\/testingstaticmembers","role":"article","title":"Testing static members","identifier":"doc:\/\/TestDRS\/documentation\/TestDRS\/TestingStaticMembers","abstract":[{"type":"text","text":"Learn how to test code that uses static members by creating mocks with TestDRS."}],"kind":"article","type":"topic"}}}